#include <stdio.h>#include <string.h>#include <console.h>extern void disassem();extern void fclose_safe();#include "das.h"int use_map, use_out;FILE *in, *out, *map;main( int argc, char *argv[] ){  register int i;  register char *a, c, option;  register int value;  int m6800;  argc = ccommand( &argv );  use_map = 0;  use_out = 1;  option = 1;  m6800 = 0;  in = out = map = NULL;  for ( i = 1; i < argc; ++i ) {    a = argv[i];    c = *a;    if ( c == '-' || c == '+' ) {      option = *++a;      value = (c == '+');    }    switch ( option ) {    case 1: {      char name[100];      in = fopen( a, "r" );      if ( !in ) {        fprintf( stderr, "das: input file %s not found.\n", a );        break;      }      if ( use_out ) {        strcpy( name, a );        strcat( name, ".dis" );        out = fopen( name, "w" );      }      else        out = stdout;      if ( use_map ) {        strcpy( name, a );        strcat( name, ".map" );        map = fopen( name, "r" );        if ( !map ) {          fprintf( stderr, "das: map file %s not found.\n", name );          break;        }      }      disassem( m6800 );      fclose_safe( &in );      fclose_safe( &out );      fclose_safe( &map );    }      break;    case '0':      m6800 = 1;      break;    case '9':      m6800 = 0;      break;    case 'm':    case 'M':      use_map = value;      break;    case 'd':    case 'D':      use_out = value;      break;    default:      fprintf( stderr, "\Usage:  das [-6809] [+|-d] [+|-m] file ...\n\        -0    disassemble 6800 code\n\        -9    disassemble 6809 code [default]\n\        +|-d  send subsequent disassemblies to files [default is +]\n\        +|-m  consult map files on subsequent disassemblies [default is -]\n" );      break;    }    option = 1;  }  fclose_safe( &in );  fclose_safe( &map );  fclose_safe( &out );}void fclose_safe( file )  FILE **file;{  register FILE *f;  f = *file;  if ( f && f != stdout && f != stdin ) {    fclose( f );    *file = NULL;  }}#define MAX_LINE	200char in_buff[MAX_LINE];int hexes;char *in_p;#define MAX_OPCODE_LENGTH	32unsigned char opcode_bytes[MAX_OPCODE_LENGTH];int opcode_bytes_index;unsigned short int pc, map_lo, map_hi;int pc_set;char (*opname)[5];char *addressing;#define NO_MAP		0#define MAP_DAS		1#define MAP_DATA	2#define MAP_ASCII	3int map_type, next_map_type, map_width;int cv_hex( c )  register char c;{  if ( c >='a' && c <= 'f' )    c -= 'a' - 'A';  if ( c >= '0' && c <= '9' )    return c - '0';  else if ( c >= 'A' && c <= 'F' )    return c - 'A' + 10;  else return -1;}unsigned long get_hex( digits, ph )  register int digits;  char **ph;{  register int result, t;  register char *p;  p = *ph;  for ( result = 0; digits; --digits ) {    t = cv_hex( *p++ );    if ( t == -1 )      break;    result = (result << 4) | t;  }  while ( *p && cv_hex( *p ) == -1 ) ++p;	/* skip non-hex space */  *ph = p;  return result;}int next_byte(){  register int result;  if ( feof( in ) )    return EOF;  ++pc;  if ( hexes <= 0 ) {    do {      if ( !fgets( in_buff, MAX_LINE, in ) )        return EOF;    } while ( !(in_buff[0] == 'S' && in_buff[1] == '1') );    in_p = &in_buff[2];    hexes = get_hex( 2, &in_p ) - 3;  /* ignore checksum */    if ( !pc_set ) {      pc = get_hex( 4, &in_p );  /* only get first address marker */      pc_set = 1;    }    else      in_p += 4;  }  result = get_hex( 2, &in_p );  --hexes;  opcode_bytes[opcode_bytes_index++] = result;  return result;}int get_index_mode( postbyte, reg, indirect )  register unsigned char postbyte;  int *reg;  int *indirect;{  register int mode;  if ( !(postbyte & 0x80) )    mode = 16;  else    mode = postbyte & 0x0F;  if ( reg )    *reg = (postbyte & 0x60) >> 5;  if ( indirect )    *indirect = (postbyte & 0x10) != 0;  return mode;}void print_list( byte, listname )  unsigned char byte;  char (*listname)[3];{  register unsigned char test, regbyte;  register int i, first;  for ( first = 1, test = 0x80, i = 7; i >= 0; test >>= 1, --i ) {    if ( byte & test ) {      if ( !first )        fputc( ',', out );      else        first = 0;      fprintf( out, "%s", listname[i] );    }  }}void check_map(){  char map_buff[MAX_LINE];  char *m;  if ( map == NULL )    return;  map_type = MAP_DAS;  if ( pc > map_hi ) {    if ( !fgets( map_buff, MAX_LINE, map ) ) {      fclose_safe( &map );      return;    }    m = map_buff;    map_lo = get_hex( 4, &m );    map_hi = get_hex( 4, &m );    if ( pc > map_hi ) {      fclose_safe( &map );      fprintf( stderr, "das: bad map range %x,%x: pc=%x\n", map_lo, map_hi, pc );      return;    }    switch ( *m++ ) {    case 'a':    case 'A':      next_map_type = MAP_ASCII;      break;    case 'd':    case 'D':      next_map_type = MAP_DATA;      break;    default:      fclose_safe( &map );      fprintf( stderr, "das: unknown map range type: %c\n", *(m-1) );      return;    }    if ( *m++ == ',' )      map_width = get_hex( 2, &m ) - 1;    else      map_width = 15;  }  if ( pc >= map_lo )    map_type = next_map_type;}void init_map(){  map_lo = map_hi = 0;  if ( !map )    map_type = MAP_DAS;  else {    pc = 1; /* force read */    check_map();  }}void disassem( m6800 )  int m6800;{  register int i, opi, op_byte;  register int addressing_mode;  register char *opcode_name;  pc_set = 0;  init_map();  if ( m6800 ) {    opname = opname4;    addressing = addressing4;  }  for (;;) {    opcode_bytes_index = 0;    opi = 0;    if ( (op_byte = next_byte()) == EOF )      break;    fprintf( out, "%04X:", pc );    check_map();    switch ( map_type ) {    case MAP_DAS:      if ( !m6800 ) {        switch ( op_byte ) {        case 0x10:          opname = opname2;          addressing = addressing2;          op_byte = next_byte();          ++opi;          break;        case 0x11:          opname = opname3;          addressing = addressing3;          op_byte = next_byte();          ++opi;          break;        default:          opname = opname1;          addressing = addressing1;          break;        }      }      addressing_mode = addressing[op_byte];      opcode_name = opname[op_byte];      if ( addressing_mode == 4 )        i = indexing_length[get_index_mode( next_byte(), 0L, 0L )];      else        i = addressing_length[addressing_mode];      break;    case MAP_DATA:    case MAP_ASCII:      i = map_hi - pc;      if ( i > map_width )        i = map_width;      break;    default:      break;    }    for ( ; i; --i )      next_byte();    for ( i = 0; i < opcode_bytes_index; ++i ) {      if ( i )        fputc( ' ', out );      fprintf( out, "%02X",  opcode_bytes[i] );    }    if ( map_type == MAP_DAS ) {	/* tab out to opcode column */      for ( ; i < 6; ++i )        fprintf( out, "   " );    }    switch ( map_type ) {    case MAP_DAS:      fprintf( out, "  %s",  opcode_name );      if ( addressing_mode != 0 ) {        if ( strlen( opcode_name ) < 4 )          fputc( ' ', out );        fprintf( out, "  " );      }      ++opi;      switch ( addressing_mode ) {      case 0:        break;      case 1:        fprintf( out, "#$%02X", opcode_bytes[opi] );        break;      case 2:        fprintf( out, "$%04X", ((int) opcode_bytes[opi] << 8) | opcode_bytes[opi+1] );        break;      case 3:        fprintf( out, "$%02X", opcode_bytes[opi] );        break;      case 4: {        int reg;        int indirect;        register int mode;        register char *regname;        mode = get_index_mode( opcode_bytes[opi], &reg, &indirect );        regname = indexing_regname[reg];        ++opi;        if ( indirect )          fputc( '[', out );        switch ( mode ) {        case 0:          fprintf( out, ",%s+", regname );          break;        case 1:          fprintf( out, ",%s++", regname );          break;        case 2:          fprintf( out, ",-%s", regname );          break;        case 3:          fprintf( out, ",--%s", regname );          break;        case 4:          fprintf( out, ",%s", regname );          break;        case 5:          fprintf( out, "B,%s", regname );          break;        case 6:          fprintf( out, "A,%s", regname );          break;        case 8:          fprintf( out, "%d,%s", opcode_bytes[opi], regname );          break;        case 9:          fprintf( out, "%d,%s", ((int) opcode_bytes[opi] << 8) | opcode_bytes[opi+1], regname );          break;        case 11:          fprintf( out, "D,%s", regname );          break;        case 12:          fprintf( out, "%d,PCR", opcode_bytes[opi] );          break;        case 13:          fprintf( out, "%d,PCR", ((int) opcode_bytes[opi] << 8) | opcode_bytes[opi+1] );          break;        case 15:          fprintf( out, "$%04X", ((int) opcode_bytes[opi] << 8) | opcode_bytes[opi+1] );          break;        case 16:          i = opcode_bytes[opi-1] & 0x1F;          if ( i > 15 )            i -= 32;          fprintf( out, "%d,%s", i, regname );          break;        default:          if ( *opcode_name != '?' )            fprintf( out, "???" );          break;        }        if ( indirect )          fputc( ']', out );        }        break;      case 5:        fprintf( out, "$%04X", pc + (char)opcode_bytes[opi] + 1 );        break;      case 6:        fprintf( out, "$%04X", pc + (((int) opcode_bytes[opi] << 8) | opcode_bytes[opi+1]) + 1 );        break;      case 7:        print_list( opcode_bytes[opi], stack_regname );        break;      case 8:        fprintf( out, "#$%04X", ((int) opcode_bytes[opi] << 8) | opcode_bytes[opi+1] );        break;      case 10:        print_list( opcode_bytes[opi], CWAI_bitname );        break;      case 11:        i = opcode_bytes[opi];        fprintf( out, "%s,%s", EXG_regname[(i >> 4) & 0xF], EXG_regname[i & 0xF] );        break;      case 12:        fprintf( out, "$%02X,X", opcode_bytes[opi] );        break;      default:        if ( *opcode_name != '?' )          fprintf( out, "???" );        break;      }      break;    case MAP_ASCII:    case MAP_DATA:	/* DEBUG */      for ( i = map_width - opcode_bytes_index + 1; i; --i )        fprintf( out, "   " );      fprintf( out, "  '" );      for ( i = 0; i < opcode_bytes_index; ++i ) {        register unsigned char c = opcode_bytes[i];        fputc( (c >= ' ' && c < 0x7F) ? c : '.', out );      }      fputc( '\'', out );      break;#if 0	/* MAP_DATA is currently output with ASCII as well */    case MAP_DATA:      break;#endif    default:      break;    }    fputc( '\n', out );  }}